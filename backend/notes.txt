
from app import create_app, mail  # Import the app factory and mail instance
from flask import request, current_app, render_template_string
from flask_mail import Message

from flask_cors import CORS



 # Allow requests from all origins


# Create the Flask app using the factory pattern
app = create_app()
CORS(app, supports_credentials=True)
@app.route('/')
def index():
    return {"message": "Welcome to my website!"}
CORS(app, origins=["http://localhost:5173"], supports_credentials=True)
@app.route('/send-email', methods=['OPTIONS', 'POST'])
def send_email_api():
    """Handle preflight requests and send emails using the user's email"""
    if request.method == "OPTIONS":
        return {"message": "Preflight request successful"}, 200

    data = request.get_json()
    subject = data.get("subject")
    sender_email = data.get("sender_email")  # ✅ Use sender's email
    recipient = data.get("recipient")
    html_content = data.get("html_content")

    if not subject or not sender_email or not recipient or not html_content:
        return {"message": "Missing required fields"}, 400

    try:
        msg = Message(
            subject=subject,
            sender=sender_email,  # ✅ Send FROM the actual user instead of MAIL_DEFAULT_SENDER
            recipients=[recipient],
            html=html_content
        )
        mail.send(msg)
        current_app.logger.info(f"Email sent from {sender_email} to {recipient}")
        return {"message": "Email sent successfully!"}, 200
    except Exception as e:
        current_app.logger.error(f"Error sending email: {str(e)}")
        return {"message": "Failed to send email."}, 500



@app.route('/send-verification-email', methods=['POST'])
def send_verification_email():
    """Endpoint to send verification email"""
    email = request.json.get('email')  
    token = "sample-verification-token"  
    subject = "Verify Your Deliveroo Account"
    verification_url = f"{request.host_url.rstrip('/')}/verify-email?token={token}"

    # Generate email HTML content dynamically
    html_content = render_template_string("""
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #333;">Welcome to Deliveroo!</h2>
        <p>Thank you for signing up. Please verify your email address by clicking the link below:</p>
        <p><a href="{{ verification_url }}" style="display: inline-block; padding: 10px 20px; background-color: #00CCBC; color: white; text-decoration: none; border-radius: 5px;">Verify Email Address</a></p>
        <p>If the button doesn't work, copy and paste this URL into your browser:</p>
        <p>{{ verification_url }}</p>
        <p>This link will expire in 24 hours.</p>
        <p>Best regards,<br>The Deliveroo Team</p>
    </div>
    """, verification_url=verification_url)

    # Send the email
    try:
        msg = Message(
            subject=subject,
            recipients=[email],
            html=html_content,
            sender=current_app.config.get('MAIL_DEFAULT_SENDER')
        )
        mail.send(msg)
        current_app.logger.info(f"Verification email sent to {email}")
        return {"message": "Verification email sent successfully!"}, 200
    except Exception as e:
        current_app.logger.error(f"Error sending verification email: {str(e)}")
        return {"message": "Failed to send verification email."}, 500

@app.route('/send-password-reset-email', methods=['POST'])
def send_password_reset_email():
    """Endpoint to send password reset email"""
    email = request.json.get('email')  # Get recipient email from request body
    token = "sample-password-reset-token"  # Generate or retrieve a real token
    subject = "Reset Your Deliveroo Password"
    reset_url = f"{request.host_url.rstrip('/')}/reset-password?token={token}"

    # Generate email HTML content dynamically
    html_content = render_template_string("""
    <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #333;">Password Reset Request</h2>
        <p>We received a request to reset your password. Click the link below to set a new password:</p>
        <p><a href="{{ reset_url }}" style="display: inline-block; padding: 10px 20px; background-color: #00CCBC; color: white; text-decoration: none; border-radius: 5px;">Reset Password</a></p>
        <p>If the button doesn't work, copy and paste this URL into your browser:</p>
        <p>{{ reset_url }}</p>
        <p>This link will expire in 1 hour.</p>
        <p>If you didn't request a password reset, you can ignore this email.</p>
        <p>Best regards,<br>The Deliveroo Team</p>
    </div>
    """, reset_url=reset_url)

    # Send the email
    try:
        msg = Message(
            subject=subject,
            recipients=[email],
            html=html_content,
            sender=current_app.config.get('MAIL_DEFAULT_SENDER')
        )
        mail.send(msg)
        current_app.logger.info(f"Password reset email sent to {email}")
        return {"message": "Password reset email sent successfully!"}, 200
    except Exception as e:
        current_app.logger.error(f"Error sending password reset email: {str(e)}")
        return {"message": "Failed to send password reset email."}, 500

if __name__ == '__main__':
    app.run(debug=True)





from datetime import datetime
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy_serializer import SerializerMixin
from werkzeug.security import check_password_hash
db = SQLAlchemy()

# BaseModel
class BaseModel:
    id = db.Column(db.Integer, primary_key=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

# User model
class User(db.Model, BaseModel, SerializerMixin):
    __tablename__ = "users"

    first_name = db.Column(db.String(80), unique=True, nullable=False)
    second_name = db.Column(db.String(80), unique=True, nullable=False)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    is_admin = db.Column(db.Boolean, default=False)
    verification_token = db.Column(db.String(255), nullable=True)  # Email verification
    reset_token = db.Column(db.String(255), nullable=True, unique=True)  # ✅ New column for password reset
    token_expiry = db.Column(db.DateTime, nullable=True)  # Expiration for both verification & reset tokens
    is_active = db.Column(db.Boolean, default=False)

    parcels = db.relationship('Parcel', back_populates='user', lazy=True)
    ratings = db.relationship('Rating', back_populates='user', lazy=True)


    serialize_rules = ('-parcels.user', '-ratings.user')
    def check_password(self, password):
        
        """Check if provided password matches the stored hashed password."""
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"<User {self.username}, Admin: {self.is_admin}>"

# Parcel model
class Parcel(db.Model, BaseModel, SerializerMixin):
    __tablename__ = 'parcels'

    description = db.Column(db.String(225), nullable=False)
    weight = db.Column(db.Float, nullable=False)
    destination = db.Column(db.String(225), nullable=False)
    status = db.Column(db.String(50), default='pending')

    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)

    user = db.relationship('User', back_populates='parcels')
    tracking_updates = db.relationship('TrackingUpdate', back_populates='parcel', lazy=True)
    ratings = db.relationship('Rating', back_populates='parcel', lazy=True)

    serialize_rules = ('-user.parcels', '-ratings.parcel', '-tracking_updates.parcel')

    def __repr__(self):
        return f"<Parcel {self.description}, Status: {self.status}>"

# TrackingUpdate model
class TrackingUpdate(db.Model, BaseModel, SerializerMixin):
    __tablename__ = 'tracking_updates'

    update_text = db.Column(db.String(255), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    parcel_id = db.Column(db.Integer, db.ForeignKey('parcels.id'), nullable=False)

    parcel = db.relationship('Parcel', back_populates='tracking_updates')

    serialize_rules = ('-parcel.tracking_updates',)

    def __repr__(self):
        return f"<TrackingUpdate for Parcel {self.parcel_id} at {self.timestamp}>"

# Rating model
class Rating(db.Model, BaseModel, SerializerMixin):
    __tablename__ = 'ratings'

    parcel_id = db.Column(db.Integer, db.ForeignKey('parcels.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    stars = db.Column(db.Integer, nullable=False)
    feedback = db.Column(db.Text, nullable=True)

    user = db.relationship('User', back_populates='ratings')
    parcel = db.relationship('Parcel', back_populates='ratings')

    serialize_rules = ('-user.ratings', '-parcel.ratings')

    def __repr__(self):
        return f"<Rating {self.stars}★ by User {self.user_id}>"









from flask import Blueprint, request, jsonify, current_app, url_for
from datetime import datetime, timedelta
from werkzeug.security import generate_password_hash
from models import User, db
from app.schemas.user_schema import (
    UserRegisterSchema,
    UserLoginSchema,
    PasswordResetRequestSchema,
    PasswordResetSchema,
    UserBaseSchema
)


from app.services.auth_service import generate_token, verify_token, blacklist_token
from app.services.email_service import send_verification_email, send_password_reset_email
from app.utils.decorators import token_required, validate_json
from app.utils.helpers import generate_secure_token
from sqlalchemy.exc import IntegrityError

auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')


# Register route
@auth_bp.route('/register', methods=['POST'])
@validate_json(UserRegisterSchema)
def register(validated_data):
    try:
        # Ensure password and confirm_password match
        if validated_data['password'] != validated_data['confirm_password']:
            return jsonify({'message': 'Passwords do not match'}), 400

        # Check if user already exists
        if User.query.filter_by(email=validated_data['email']).first():
            return jsonify({'message': 'User already exists with this email'}), 409

    
        hashed_password = generate_password_hash(validated_data['password'])

        # Generate verification token
        token = generate_secure_token()

        # Create new user (default is_active=False)
        new_user = User(
            first_name=validated_data['first_name'],
            second_name=validated_data['second_name'],
            username=validated_data['username'],
            email=validated_data['email'],
            password_hash=hashed_password,
            verification_token=token,
            token_expiry=datetime.utcnow() + timedelta(hours=24),
            is_active=False
        )

        db.session.add(new_user)
        
        # Send verification email
        try:
            verification_url = url_for('auth.verify_email', token=token, _external=True)
            email_sent = send_verification_email(new_user.email, token)
            
            if not email_sent:
                current_app.logger.error(f"Failed to send verification email to {new_user.email}")
                db.session.rollback()  # Roll back if email fails
                return jsonify({'message': 'Registration failed due to email service issue'}), 500
                
            # Only commit if email was sent successfully
            db.session.commit()
            
            return jsonify({
                'message': 'User registered successfully. Please check your email to verify your account.',
                'user_id': new_user.id
            }), 201
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Failed to send verification email: {e}")
            return jsonify({'message': 'Registration failed due to email service issue'}), 500

    except IntegrityError:
        db.session.rollback()
        return jsonify({'message': 'Username or email already exists'}), 409
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error during registration: {e}")
        return jsonify({'message': 'An error occurred during registration'}), 500

from flask_cors import cross_origin

@auth_bp.route('/verify-email', methods=['OPTIONS', 'GET', 'POST'])
@cross_origin()
def verify_email():
    """Verify the user's email using the token from request."""

    if request.method == "OPTIONS":
        return jsonify({"message": "CORS preflight success"}), 200

    # Debugging: Log received request data
    data = request.get_json()
    print("Received Data:", data)  # ✅ Debug incoming request

    # Extract token properly
    token = None
    if request.method == "POST":
        token = data.get("token")
    else:
        token = request.args.get("token")

    if not token or not isinstance(token, str):
        return jsonify({"message": "Missing or invalid verification token"}), 400

    try:
        user = User.query.filter_by(verification_token=token).first()
        
        if not user:
            print(f"Invalid token received: {token}")  # ✅ Debug invalid tokens
            return jsonify({"message": "Invalid token"}), 400

        user.is_active = True
        user.verification_token = None  # Remove token after verification
        db.session.commit()

        return jsonify({"message": "Email verified successfully"}), 200

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error during email verification: {e}")
        print(f"Exception Traceback: {e}")  # ✅ Debug full error traceback
        return jsonify({'message': 'An error occurred during email verification'}), 500

@auth_bp.route('/login', methods=['POST'])
@validate_json(UserLoginSchema)
def login(validated_data):
    try:
        user = User.query.filter_by(email=validated_data['email']).first()

        if not user or not user.check_password(validated_data['password']):
            return jsonify({'message': 'Invalid email or password'}), 401

        # Check if user account is active
        if not user.is_active:
            return jsonify({'message': 'Please verify your email before logging in'}), 401

        # Generate JWT token
        token = generate_token(user.id)

        response_data = {
            'message': 'Login successful',
            'token': token,
            'user': UserBaseSchema().dump(user)
        }

        # ✅ Check if user is admin and redirect accordingly
        if user.is_admin:
            response_data["redirect"] = "/admin-dashboard"
        else:
            response_data["redirect"] = "/dashboard"

        return jsonify(response_data), 200

    except Exception as e:
        current_app.logger.error(f"Error during login: {e}")
        return jsonify({'message': 'An error occurred during login'}), 500



@auth_bp.route('/password-reset-request', methods=['POST'])
@validate_json(PasswordResetRequestSchema)
def request_password_reset(validated_data):
    """Handle password reset request and send an email with a reset token."""
    try:
        user = User.query.filter_by(email=validated_data['email']).first()

        if not user:
            return jsonify({'message': 'If your email is registered, you will receive a password reset link'}), 200

        # Generate reset token
        token = generate_secure_token()
        user.reset_token = token  
        user.token_expiry = datetime.utcnow() + timedelta(hours=1)

        # Send password reset email
        reset_url = url_for('auth.reset_password', token=token, _external=True)


        email_sent = send_password_reset_email(user.email, token)

        if not email_sent:
            db.session.rollback()
            current_app.logger.error(f"Failed to send password reset email to {user.email}")
            return jsonify({'message': 'If your email is registered, you will receive a password reset link'}), 200

        db.session.commit()
        return jsonify({'message': 'If your email is registered, you will receive a password reset link'}), 200
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error during password reset request: {e}")
        print(f"Error Traceback: {e}")  # ✅ Add this for debugging
        return jsonify({'message': 'An error occurred during password reset request'}), 500


@auth_bp.route('/password-reset', methods=['POST'])
def reset_password():
    """Validate password reset token and update user's password."""
    try:
        data = request.get_json()
        
        # Debugging: Print received data
        print("Received Data:", data)

        # Extract data from request
        token = data.get('token')
        password = data.get('password')
        confirm_password = data.get('confirm_password')

        if not token or not password or not confirm_password:
            return jsonify({'message': 'Token, password, and confirm password are required'}), 400

        # Debugging: Check if token matches any user
        user = User.query.filter_by(reset_token=token).first()
        if not user:
            print("Invalid Token:", token)
            return jsonify({'message': 'Invalid or expired token'}), 400

        # Ensure token has not expired
        if user.token_expiry is None or user.token_expiry < datetime.utcnow():
            return jsonify({'message': 'Password reset link has expired'}), 400

        # Validate password confirmation
        if password != confirm_password:
            return jsonify({'message': 'Passwords do not match'}), 400

        # Update user's password securely
        user.password_hash = generate_password_hash(password)
        user.reset_token = None  # Clear token after successful reset
        user.token_expiry = None
        db.session.commit()

        return jsonify({'message': 'Password updated successfully'}), 200

    except Exception as e:
        db.session.rollback()
        print(f"Error during password reset: {e}")  # ✅ Debugging
        return jsonify({'message': 'An error occurred during password reset'}), 500


# Resend verification email
@auth_bp.route('/resend-verification', methods=['POST'])
@validate_json(PasswordResetRequestSchema)
def resend_verification(validated_data):
    try:
        user = User.query.filter_by(email=validated_data['email']).first()
        
        if not user:
            # Return generic response for security
            return jsonify({'message': 'If your email is registered, you will receive a verification link'}), 200
            
        if user.is_active:
            return jsonify({'message': 'This account is already verified'}), 400
            
        # Generate new verification token
        token = generate_secure_token()
        user.verification_token = token
        user.token_expiry = datetime.utcnow() + timedelta(hours=24)
        
        # Send verification email
        verification_url = url_for('auth.verify_email', token=token, _external=True)
        email_sent = send_verification_email(user.email, token)
        
        if not email_sent:
            db.session.rollback()
            current_app.logger.error(f"Failed to send verification email to {user.email}")
            return jsonify({'message': 'If your email is registered, you will receive a verification link'}), 200
        
        db.session.commit()
        return jsonify({'message': 'If your email is registered, you will receive a verification link'}), 200
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error during resend verification: {e}")
        return jsonify({'message': 'An error occurred during resend verification'}), 500


# Logout route
@auth_bp.route('/logout', methods=['POST'])
@token_required
def logout(current_user):
    try:
        # Get token from the Authorization header
        auth_header = request.headers.get('Authorization')
        if auth_header and auth_header.startswith('Bearer '):
            token = auth_header.split(' ')[1]
            blacklist_token(token)
            return jsonify({'message': 'Successfully logged out'}), 200
        
        return jsonify({'message': 'Token is missing'}), 401
    except Exception as e:
        current_app.logger.error(f"Error during logout: {e}")
        return jsonify({'message': 'An error occurred during logout'}), 500


# Helper function for generating secure tokens
def generate_secure_token():
    """
    Generate a secure random token for email verification or password reset.
    This replaces the imported generate_verification_token function.
    
    Returns:
        str: A secure random token
    """
    import secrets
    return secrets.token_urlsafe(32)  # Generate a 32-byte URL-safe token



curl -X POST "http://127.0.0.1:5000/api/auth/register" \
     -H "Content-Type: application/json" \
     -d '{
       "first_name": "Test",
       "second_name": "User",
       "username": "testuser",
       "email": "godweenlesenku@gmail.com",
       "password": "SecurePassword123!",
       "confirm_password": "SecurePassword123!"
     }'
